package trikita.anvilgen

import com.squareup.javapoet.*
import groovy.lang.Closure
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.lang.Deprecated
import java.lang.reflect.Method
import java.net.URL
import java.net.URLClassLoader
import java.util.*
import java.util.jar.JarFile
import javax.lang.model.element.Modifier

open class DSLGeneratorTask : DefaultTask() {

    lateinit var jarFile: File
    lateinit var dependencies: List<File>
    lateinit var taskName: String
    lateinit var javadocContains: String
    lateinit var outputDirectory: String
    lateinit var outputClassName: String
    lateinit var packageName: String
    var superclass: ClassName? = null

    @TaskAction
    fun generate() {
        var attrsBuilder = TypeSpec.classBuilder(outputClassName)
                .addJavadoc("DSL for creating views and settings their attributes.\n" +
                        "This file has been generated by " +
                        "{@code gradle $taskName}.\n" +
                        "$javadocContains.\n" +
                        "Please, don't edit it manually unless for debugging.\n")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)

        if (superclass != null) {
            attrsBuilder = attrsBuilder.superclass(superclass)
        }

        var attrMethods = sortedMapOf<MethodKey, MethodSpec.Builder>()

        forEachView { view ->
            processViews(attrsBuilder, view)
            forEachMethod(view) { m, name, arg, isListener ->
                attrMethods = processAttrs(attrMethods, m, name, arg, isListener)
            }
        }

        finalizeAttrs(attrsBuilder, attrMethods)

        JavaFile.builder(packageName, attrsBuilder.build())
                .build()
                .writeTo(project.file("src/$outputDirectory/java"))
    }

    fun forEachView(cb: (Class<*>) -> Unit) {
        val urls = mutableListOf(URL("jar", "", "file:${jarFile.absolutePath}!/"))
        for (dep in dependencies) {
            urls.add(URL("jar", "", "file:${dep.absolutePath}!/"))
        }
        val loader = URLClassLoader(urls.toTypedArray(), javaClass.classLoader)
        val viewClass = loader.loadClass("android.view.View")

        val jar = JarFile(jarFile)
        val list = Collections.list(jar.entries())
        list.sortBy { it.name }

        for (e in list) {
            if (e.name.endsWith(".class")) {
                val className = e.name.replace(".class", "").replace("/", ".")

                // Skip inner classes
                if (className.contains('$')) {
                    continue
                }
                try {
                    val c = loader.loadClass(className)
                    if (viewClass.isAssignableFrom(c) &&
                            java.lang.reflect.Modifier.isPublic(c.modifiers)) {
                        cb(c)
                    }
                } catch (ignored: NoClassDefFoundError) {
                    // Simply skip this class.
                    ignored.printStackTrace()
                }
            }
        }
    }

    fun forEachMethod(c: Class<*>, cb: (Method, String, Class<*>, Boolean) -> Unit) {
        val declaredMethods = c.declaredMethods.clone()
        declaredMethods.sortBy { it.name }
        for (m in declaredMethods) {
            if (!java.lang.reflect.Modifier.isPublic(m.modifiers) || m.isSynthetic || m.isBridge) {
                continue
            }

            val parameterType = getMethodParameterType(m) ?: continue

            if (m.name.matches(Regex("^setOn.*Listener$"))) {
                val name = m.name
                cb(m, "on" + name.substring(5, name.length - 8), parameterType, true)
            } else if (m.name.startsWith("set") && m.parameterCount == 1) {
                val name = Character.toLowerCase(m.name[3]).toString() + m.name.substring(4)
                cb(m, name, parameterType, false)
            }
        }
    }

    fun getMethodParameterType(m: Method): Class<*>? {
        if (m.parameterTypes.size == 0) {
            return null
        }

        val parameterType = m.parameterTypes[0]
        if (!java.lang.reflect.Modifier.isPublic(parameterType.modifiers)) {
            // If the parameter is not public then the method is inaccessible for us.
            return null
        } else if (m.annotations != null) {
            for (a in m.annotations) {
                // Don't process deprecated methods.
                if (a.annotationClass.equals(Deprecated::class)) {
                    return null
                }
            }
        } else if (m.declaringClass.canonicalName == "android.view.View") {
            return parameterType
        }

        // Check if the method overrode from a super class.
        var supClass = m.declaringClass.superclass
        while (true) {
            if (supClass == null) {
                break
            }
            try {
                supClass.getMethod(m.name, *m.parameterTypes)
                return null
            } catch (ignored: NoSuchMethodException) {
                // Intended to occur
            }

            if (supClass.canonicalName == "android.view.View") {
                break
            }
            supClass = supClass.superclass
        }
        return parameterType
    }

    //
    // Views generator functions:
    // For each view generates a function that calls v(C), where C is a view
    // class, e.g. FrameLayout.class => frameLayout() { v(FrameLayout.class) }
    //
    fun processViews(builder: TypeSpec.Builder, view: Class<*>) {
        // Skip abstract views.
        // We shortcircuit it here, since we still want to generate attrs for these kinds of views.
        if (java.lang.reflect.Modifier.isAbstract(view.modifiers)) {
            return
        }
        // Skip classes without single argument Context constructors
        if (!view.constructors.isEmpty()) { // No constructors. Valid, since superclass should have the right one.
            val contextConstructor = view.constructors.filter { it ->
                it.parameterCount == 1 && it.parameters[0].type.canonicalName == "android.content.Context"
            }.firstOrNull()
            contextConstructor ?: return
        }

        val className = view.canonicalName
        var name = view.simpleName
        val extension = project.extensions.getByName("anvilgen") as AnvilGenPluginExtension

        val quirk = extension.quirks[className]
        if (quirk != null) {
            val alias = quirk["__viewAlias"]
            // if the whole view class is banned - do nothing
            if (alias == false) {
                return
            } else if (alias != null) {
                name = alias as String
            }
        }
        name = toCase(name, { c -> Character.toLowerCase(c) })
        val baseDsl = ClassName.get("trikita.anvil", "BaseDSL")
        val result = ClassName.get("trikita.anvil", "BaseDSL", "ViewClassResult")
        val factoryName = "${view.simpleName}FactoryFunc"
        builder.addMethod(MethodSpec.methodBuilder(name)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(result)
                .addStatement("return \$T.v($factoryName.getInstance())", baseDsl)
                .build())
        builder.addMethod(MethodSpec.methodBuilder(name)
                .addParameter(ParameterSpec.builder(ClassName.get("trikita.anvil",
                        "Anvil", "Renderable"), "r").build())
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(TypeName.VOID.box())
                .addStatement("return \$T.v($factoryName.getInstance(), r)", baseDsl)
                .build())

        generateViewFactory(builder, view, factoryName)
    }

    //
    // View factory func generator
    //
    fun generateViewFactory(builder: TypeSpec.Builder, view: Class<*>, factoryName: String) {
        val cls = TypeName.get(view)
        val factoryFuncType = ClassName.get("trikita.anvil", "Anvil", "FactoryFunc")

        val factoryBuilder = TypeSpec.classBuilder(factoryName)
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .addSuperinterface(ParameterizedTypeName.get(factoryFuncType, cls))

        factoryBuilder.addField(FieldSpec
                .builder(ClassName.get("", factoryName), "instance")
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
                .initializer("null")
                .build())

        factoryBuilder.addMethod(MethodSpec
                .methodBuilder("getInstance")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(ClassName.get("", factoryName))
                .beginControlFlow("if(instance == null)")
                .addStatement("instance = new $factoryName()")
                .endControlFlow()
                .addStatement("return instance")
                .build())

        factoryBuilder.addMethod(MethodSpec
                .methodBuilder("apply")
                .addModifiers(Modifier.PUBLIC)
                .returns(view)
                .addParameter(ClassName.get("android.content", "Context"), "c")
                .addStatement("return new \$T(c)", view)
                .build())

        builder.addType(factoryBuilder.build())
        builder.build()
    }

    //
    // Attrs generator functions
    //
    fun processAttrs(methods: SortedMap<MethodKey, MethodSpec.Builder>,
                     method: Method,
                     name: String,
                     klass: Class<*>,
                     isListener: Boolean): SortedMap<MethodKey, MethodSpec.Builder> {
        val fn: MethodSpec.Builder?
        val key = MethodKey(name, klass)
        if (isListener) {
            fn = listener(methods[key], method)
        } else {
            fn = setter(methods[key], method)
        }
        if (fn != null) {
            methods.put(key, fn)
        }
        return methods
    }

    fun finalizeAttrs(builder: TypeSpec.Builder, methods: MutableMap<MethodKey, MethodSpec.Builder>) {
        // .sort { it.key.method + " " + it.key.cls.name }
        methods.forEach {
            var cls = TypeName.get(it.key.cls).box()
            if (cls.isPrimitive) {
                cls = cls.box()
            }
            val baseDsl = ClassName.get("trikita.anvil", "BaseDSL")
            val attrFuncType = ClassName.get("trikita.anvil", "Anvil", "AttrFunc")
            val className = toCase(it.key.method, { c -> Character.toUpperCase(c) }) +
                    "Func" + Integer.toHexString(cls.hashCode())
            val attrBuilder = TypeSpec.classBuilder(className)
                    .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                    .addSuperinterface(ParameterizedTypeName.get(attrFuncType, cls))
            attrBuilder.addField(FieldSpec
                    .builder(ClassName.get("", className), "instance")
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                    .initializer("new $className()")
                    .build())
            attrBuilder.addMethod(it.value.build())
            builder.addType(attrBuilder.build())

            val wrapperMethod = MethodSpec.methodBuilder(it.key.method)
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                    .addParameter(ParameterSpec.builder(it.key.cls, "arg").build())
                    .returns(TypeName.VOID.box())
                    .addStatement("return \$T.attr($className.instance, arg)", baseDsl)
            builder.addMethod(wrapperMethod.build())
        }
    }

    fun attrApplyBuilder(m: Method): MethodSpec.Builder {
        val cls = TypeName.get(m.parameterTypes[0]).box()
        return MethodSpec.methodBuilder("apply")
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ClassName.get("android.view", "View"), "v")
                .addParameter(ParameterSpec.builder(cls, "arg")
                        .addModifiers(Modifier.FINAL).build())
                .addParameter(ParameterSpec.builder(cls, "old")
                        .addModifiers(Modifier.FINAL).build())
    }

    fun listener(inputBuilder: MethodSpec.Builder?, m: Method): MethodSpec.Builder {
        var builder = inputBuilder ?: attrApplyBuilder(m)

        val className = m.declaringClass.canonicalName
        val listenerClass = m.parameterTypes[0]

        val listener = TypeSpec.anonymousClassBuilder("")
                .addSuperinterface(listenerClass)
        val declaredMethods = listenerClass.declaredMethods.clone()
        declaredMethods.sortBy { it.name }

        declaredMethods.forEach { lm ->
            val methodBuilder = MethodSpec.methodBuilder(lm.name)
                    .addModifiers(Modifier.PUBLIC)
                    .returns(lm.returnType)

            var args = ""
            lm.parameterTypes.forEachIndexed { i, v ->
                methodBuilder.addParameter(v, "a$i")
                args += (if (i != 0) ", " else "") + "a$i"
            }

            if (lm.returnType.equals(Void.TYPE)) {
                methodBuilder
                        .addStatement("arg.\$L($args)", lm.name)
                        .addStatement("\$T.render()", ClassName.get("trikita.anvil", "Anvil"))
            } else {
                methodBuilder
                        .addStatement("\$T r = arg.\$L($args)", lm.returnType, lm.name)
                        .addStatement("\$T.render()", ClassName.get("trikita.anvil", "Anvil"))
                        .addStatement("return r")
            }

            listener.addMethod(methodBuilder.build())
        }

        if (className == "android.view.View") {
            builder = attrApplyBuilder(m)
                    .beginControlFlow("if (arg != null)", m.declaringClass)
                    .addStatement("v.${m.name}(\$L)", listener.build())
                    .nextControlFlow("else")
                    .addStatement("v.${m.name}((\$T) null)", listenerClass)
                    .endControlFlow()
        } else {
            builder.beginControlFlow("if (v instanceof \$T)", m.declaringClass)
                    .beginControlFlow("if (arg != null)", m.declaringClass)
                    .addStatement("((\$T) v).${m.name}(\$L)", m.declaringClass,
                            listener.build())
                    .nextControlFlow("else")
                    .addStatement("((\$T) v).${m.name}((\$T) null)", m.declaringClass,
                            listenerClass)
                    .endControlFlow()
                    .endControlFlow()
        }

        return builder
    }

    fun setter(inputBuilder: MethodSpec.Builder?, m: Method): MethodSpec.Builder? {
        var builder = inputBuilder ?: attrApplyBuilder(m)

        val className = m.declaringClass.canonicalName
        val extension = project.extensions.getByName("anvilgen") as AnvilGenPluginExtension
        val quirks = extension.quirks[className]
        if (quirks != null) {
            val argClass = m.parameterTypes[0].canonicalName
            val closure = quirks["${m.name}:$argClass"]
            if (closure != null) {
                return (closure as Closure<MethodSpec.Builder?>).call(builder)
            }
            val nameClosure = quirks[m.name]
            if (nameClosure != null) {
                return (nameClosure as Closure<MethodSpec.Builder?>).call(builder)
            }
        }

        if (className == "android.view.View") {
            builder = attrApplyBuilder(m)
                    .addStatement("v.${m.getName()}(arg)")
        } else {
            builder.beginControlFlow("if (v instanceof \$T)", m.declaringClass)
                    .addStatement("((\$T) v).${m.name}(arg)", m.declaringClass)
                    .endControlFlow()
        }

        return builder
    }

    fun toCase(s: String, fn: (Char) -> Char): String {
        return fn(s[0]).toString() + s.substring(1)
    }

    class MethodKey(val method: String, val cls: Class<*>) : Comparable<MethodKey> {

        override fun compareTo(other: MethodKey): Int {
            val methodCompare = method.compareTo(other.method)
            if (methodCompare != 0) {
                return methodCompare
            }
            return cls.name.compareTo(other.cls.name)
        }

        override fun equals(other: Any?): Boolean {
            if (other !is MethodKey) {
                return false
            }
            return method.equals(other.method) && cls.name.equals(other.cls.name)
        }

        override fun hashCode(): Int {
            return method.hashCode() + 43 * cls.canonicalName.hashCode()
        }
    }
}

